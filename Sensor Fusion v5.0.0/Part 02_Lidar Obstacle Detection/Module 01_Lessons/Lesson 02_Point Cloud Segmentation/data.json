{
  "data": {
    "lesson": {
      "id": 837626,
      "key": "1c1ef843-6cc1-4ce4-b597-fe99158f7fc0",
      "title": "Point Cloud Segmentation",
      "semantic_type": "Lesson",
      "is_public": true,
      "version": "1.0.0",
      "locale": "en-us",
      "summary": "In this lesson, you will be using Ransac with a plane model to segment point cloud data and separate it into points that are part of the road and points that are not.",
      "lesson_type": "Classroom",
      "display_workspace_project_only": false,
      "resources": {
        "files": [
          {
            "name": "Videos Zip File",
            "uri": "https://zips.udacity-data.com/1c1ef843-6cc1-4ce4-b597-fe99158f7fc0/837626/1561072930414/Point+Cloud+Segmentation+Videos.zip"
          },
          {
            "name": "Transcripts Zip File",
            "uri": "https://zips.udacity-data.com/1c1ef843-6cc1-4ce4-b597-fe99158f7fc0/837626/1561072926032/Point+Cloud+Segmentation+Subtitles.zip"
          }
        ],
        "google_plus_link": null,
        "career_resource_center_link": null,
        "coaching_appointments_link": null,
        "office_hours_link": null,
        "aws_provisioning_link": null
      },
      "project": null,
      "lab": null,
      "concepts": [
        {
          "id": 837589,
          "key": "20d3c1d9-3d76-4917-b83d-1f4bc8b62d41",
          "title": "Segmentation",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "20d3c1d9-3d76-4917-b83d-1f4bc8b62d41",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 837586,
              "key": "2124b1b9-236c-477f-b55b-405bb65df9e1",
              "title": "Header Text",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# Segmentation",
              "instructor_notes": ""
            },
            {
              "id": 837587,
              "key": "d2a7f746-d122-458d-990c-169a0a4bb4c6",
              "title": "ND313 C1 L2 A01 Segmentation Introduction",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "AtkxjX4F2pU",
                "china_cdn_id": "AtkxjX4F2pU.mp4"
              }
            },
            {
              "id": 837588,
              "key": "e5414405-7fd0-47d8-91b5-d995f0e7f0d2",
              "title": "Overview offor Segmentation",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "We want to be able to locate obstacles in the scene. However, some objects in our scene our not obstacles. What would be objects that appear in the pcd but are not obstacles? For the most part, any free space on the road is not an obstacle, and if the road is flat it’s fairly straightforward to pick out road points from non-road points. To do this we will use a method called Planar Segmentation which uses the RANSAC (random sample consensus) algorithm.",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 858911,
          "key": "90639c75-36ad-4b48-8021-ae8ceeb7483e",
          "title": "Michael on Detection and Segmentation",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "90639c75-36ad-4b48-8021-ae8ceeb7483e",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 858912,
              "key": "adacedfb-648b-4898-8bda-00421ea71b37",
              "title": "ND313 Michael Intv 13 How Do You Use Lidar To Detect Object In Environment V2",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "E3qIeLVy6Uw",
                "china_cdn_id": "E3qIeLVy6Uw.mp4"
              }
            }
          ]
        },
        {
          "id": 837594,
          "key": "bd90c93f-ff68-4945-94c2-dd9917738924",
          "title": "Point Processing",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "bd90c93f-ff68-4945-94c2-dd9917738924",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 837590,
              "key": "53b43598-5239-4a85-a1de-ec193ccd8fd1",
              "title": "Header Text",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# Point Processing",
              "instructor_notes": ""
            },
            {
              "id": 840252,
              "key": "f76e6f70-6857-4658-bccb-dc6ff08238fa",
              "title": "ND313 C1 L2 A03 Point Processing [LB]",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "ZXZL0l4t0X0",
                "china_cdn_id": "ZXZL0l4t0X0.mp4"
              }
            },
            {
              "id": 837591,
              "key": "4d74926b-6b9c-46d4-b725-28315c6ecfb9",
              "title": "Creating Point Processor",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "The first thing you are going to do is create a `processPointClouds` object. This is defined by the `src/processPointClouds.cpp` and `src/processPointClouds.h` files. This object is going to contain all the methods that you will be using in this module for processing lidar data. The process object also has helper methods for loading and saving PCD files. By the time you compete this exercise, the code should compile but you will still need to complete the next few concepts before getting results.\n\n## Instructions\n\n- Open the `src/environment.cpp` file.\n- Inside the function `simpleHighway`, create a `processPointClouds` object. You can do this either on the stack or the heap.\n- The processor should use point cloud type of `pcl::PointXYZ`.",
              "instructor_notes": ""
            },
            {
              "id": 837629,
              "key": "cdcb0d00-7cc7-4571-bc4f-978f32f5c919",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r831540c837485xREACTy8c3xugx",
              "pool_id": "autonomousgpu",
              "view_id": "react-ah3lg",
              "gpu_capable": true,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "port": 3000,
                    "ports": [],
                    "userCode": "",
                    "openFiles": [],
                    "showFiles": true,
                    "allowClose": true,
                    "allowSubmit": false,
                    "terminalTitle": "BASH",
                    "actionButtonText": "Desktop",
                    "openTerminalOnStartup": true
                  },
                  "kind": "react"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            },
            {
              "id": 837592,
              "key": "358156c0-9ca1-4111-87a2-67a87f008020",
              "title": "Solution",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Solution",
              "instructor_notes": ""
            },
            {
              "id": 837593,
              "key": "63adbbda-330b-4a65-85a4-5d222f09d22e",
              "title": "ND313 C1 L2 A04 Point Processing Solution",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "p95bjDsEhz0",
                "china_cdn_id": "p95bjDsEhz0.mp4"
              }
            }
          ]
        },
        {
          "id": 837601,
          "key": "ddf60438-64d4-4de5-a432-0ecae0c4634c",
          "title": "Segmenting the Plane with PCL",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "ddf60438-64d4-4de5-a432-0ecae0c4634c",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 837595,
              "key": "5cecf3f1-1c44-4316-b54b-ba0034bf1c9e",
              "title": "Header Text",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# Segmenting the Plane with PCL",
              "instructor_notes": ""
            },
            {
              "id": 840253,
              "key": "b6aefd39-c7d4-4fd8-818f-0b8baf0ac00c",
              "title": "ND313 C1 L2 A05 Using PCL To Segment Planne [LB]",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "jo3ZS04TDSU",
                "china_cdn_id": "jo3ZS04TDSU.mp4"
              }
            },
            {
              "id": 837596,
              "key": "b9df273b-34f5-4daf-87d3-af6484e5da07",
              "title": "Using PCL to segment Plane",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "In this exercise you will be separating the points that belong to the road from the points that belong to the scene.\n\n## The SegmentPlane Function Stub\n\nLet's put the point processor to use now.\n\nYou will define the `SegmentPlane` function in `src/processPointClouds.cpp`. There is already a declaration for this function, and you just need to fill in the defintion. At the top of the function, you will notice a template parameter `PointT`. You will be using this as a variable to represent any type of point cloud, and it will come in handy later when you are processing point clouds with intensity values.\n\n### SegmentPlane Function Signature\n\n```cpp\n std::pair<typename pcl::PointCloud<PointT>::Ptr, typename pcl::PointCloud<PointT>::Ptr> SegmentPlane(typename pcl::PointCloud<PointT>::Ptr cloud, int maxIterations, float distanceThreshold);\n```\n\nThe function accepts a point cloud, max iterations, and distance tolerance as arguments. Segmentation uses an iterative process. More iterations have a chance of returning better results but take longer. The segmentation algorithm fits a plane to the points and uses the distance tolerance to decide which points belong to that plane. A larger tolerance includes more points in the plane. \n\nHave a look at the return type in the code above. `SegmentPlane` will return a `std::pair` holding point cloud pointer types. If you are not familiar with pairs check out the documentation [here](http://www.cplusplus.com/reference/utility/pair/pair/). You will use the pair object to hold your segmented results for the obstacle point cloud and the road point cloud. This way, you can later visualize both point clouds in the pcl viewer and analyze the results. \n\n### SegmentPlane Body\n\n```cpp\n// Time segmentation process\nauto startTime = std::chrono::steady_clock::now();\n\n// TODO:: Fill in the function to segment cloud into two parts, the drivable plane and obstacles\n    \nauto endTime = std::chrono::steady_clock::now();\nauto elapsedTime = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime);\nstd::cout << \"plane segmentation took \" << elapsedTime.count() << \" milliseconds\" << std::endl;\n```\n\nThe first thing you see in the code above in the `SegmentPlane` function stub is a timer. This can be useful for measuring how long it takes to run the function. If it’s taking a really long time to process the segmentation, then the function is not going to be useful running in real-time on a self-driving car. \n\n## Instructions\n\nTo get started filling in the function you can use pcl’s segmentation object. For reference check out this pcl tutorial on [segmentation](http://pointclouds.org/documentation/tutorials/extract_indices.php#extract-indices). In particular check out lines 38-48. Have a look at the walkthrough below for an explanation of these lines, and try to implement them yourself in the workspace.",
              "instructor_notes": ""
            },
            {
              "id": 837597,
              "key": "bf86e59c-7598-4e36-a8d6-e0f38a6ad9ca",
              "title": "ND313 C1 L2 A06 Walking Through Pcl Segmentation",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "8n3BrJ51dSU",
                "china_cdn_id": "8n3BrJ51dSU.mp4"
              }
            },
            {
              "id": 837598,
              "key": "f3caef76-c3ea-4e05-8995-58eca27f2ad1",
              "title": "Instructions",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Implement the SegmentPlane Function",
              "instructor_notes": ""
            },
            {
              "id": 837630,
              "key": "465ef79d-200d-4b70-9617-2c0021c59ac5",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r831540c837485xREACTy8c3xugx",
              "pool_id": "autonomousgpu",
              "view_id": "react-hpxf5",
              "gpu_capable": true,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "port": 3000,
                    "ports": [],
                    "userCode": "",
                    "openFiles": [],
                    "showFiles": true,
                    "allowClose": true,
                    "allowSubmit": false,
                    "terminalTitle": "BASH",
                    "actionButtonText": "Desktop",
                    "openTerminalOnStartup": true
                  },
                  "kind": "react"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            },
            {
              "id": 837599,
              "key": "5c12743c-c2ed-4bfe-87a1-dceb266db2b6",
              "title": "Solution",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Solution",
              "instructor_notes": ""
            },
            {
              "id": 837600,
              "key": "f4d6c9eb-6528-4c22-8139-a6843e12f444",
              "title": "ND313 C1 L2 A07 Segmenting Plane With PCL Solution",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "80hf7xu-_8Y",
                "china_cdn_id": "80hf7xu-_8Y.mp4"
              }
            }
          ]
        },
        {
          "id": 837607,
          "key": "23dee5bb-6b5c-49a6-90d9-93c154e0fdfa",
          "title": "Separating Point Clouds",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "23dee5bb-6b5c-49a6-90d9-93c154e0fdfa",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 837602,
              "key": "959d1511-2bbb-4f49-817c-8d22a527424f",
              "title": "Header Text",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# Separating Point Clouds\n\nIn the previous exercise, you got inliers which are indices for the fitted plane. Now you will be using these inliers to create the plane point cloud and obstacle point cloud.",
              "instructor_notes": ""
            },
            {
              "id": 840284,
              "key": "bdaee10b-20b8-4c34-adcb-a16175d9f6b9",
              "title": "ND313 C1 L2 A08 Separating Point Clouds Pt 1 [LB]",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "K_JuSBXiM_4",
                "china_cdn_id": "K_JuSBXiM_4.mp4"
              }
            },
            {
              "id": 840286,
              "key": "8d05ca08-3a71-4f59-ad9a-1733414b236b",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Instructions\n\nYou can separate point clouds by calling the `SeparateClouds` function  from `processPointCloud`. You can use this function inside `SegmentPlane` with the calculated inliers and input cloud. \n\nInside the `SeparateClouds` function stub, create two new point cloud pointers, one for obstacles (non-plane points), and one for road (plane points). The inliers can be added to the plane cloud by looping over the inlier indices and pushing the corresponding inlier point into the plane cloud’s point vector. \n\nTo generate the obstacle cloud, one way to use PCL to do this is to use an `extract` object, which subtracts the plane cloud from the input cloud. Now you can return the `std::pair` with the newly created obstacle and plane clouds: \n\n```cpp\nstd::pair<typename pcl::PointCloud<PointT>::Ptr, typename pcl::PointCloud<PointT>::Ptr> segResult(obstCloud,planeCloud);\n```\nThe pcl segmentation [tutorial](http://pointclouds.org/documentation/tutorials/extract_indices.php#extract-indices) shows how to use an `extract` object in lines 67-70.\n\nBack in environment.cpp you can then call pointProcessor function on the input cloud and render the two segmented point clouds in different colors.\n```cpp\nstd::pair<pcl::PointCloud<pcl::PointXYZ>::Ptr, pcl::PointCloud<pcl::PointXYZ>::Ptr> segmentCloud = pointProcessor->SegmentPlane(inputCloud, 100, 0.2);\nrenderPointCloud(viewer,segmentCloud.first,\"obstCloud\",Color(1,0,0));\nrenderPointCloud(viewer,segmentCloud.second,\"planeCloud\",Color(0,1,0));\n```\n### Notes\nThe above example is using 100 iterations, and a distance tolerance of 0.2 meters. You are highly encouraged to play around and experiment with these values! This point cloud is very simple and 100 iterations are way more than needed. You can also monitor how changing the iterations affects the time it takes for the segmentation function to process using the functions predefined timer log. \nBefore rendering the two clouds you will want to remember to turn off rendering from the input cloud done in the previous lesson, otherwise the clouds will all overlap, and it will be hard to distinguish the segmented ones. The renderPointCloud function includes color options (Red,Green,Blue). By default the cloud is white if no color is specified. Here the obstacle cloud as is rendered as red, and the plane cloud as green. \n",
              "instructor_notes": ""
            },
            {
              "id": 837603,
              "key": "9c875bc0-c7a4-4544-a273-463a6d79f597",
              "title": "Segment Simulation PCD",
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2019/March/5c840357_seg1/seg1.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/9c875bc0-c7a4-4544-a273-463a6d79f597",
              "caption": "Segment and separating point clouds: road points in green, and other obstacle points in red",
              "alt": "Segment and separating point clouds: road points in green, and other obstacle points in red",
              "width": 953,
              "height": 537,
              "instructor_notes": null
            },
            {
              "id": 840285,
              "key": "cd7ab2f0-8669-44b7-9f11-82fd58b53139",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Separate Point Clouds",
              "instructor_notes": ""
            },
            {
              "id": 837632,
              "key": "7c3634e7-f7bd-4843-ab6e-4c09b2345f19",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r831540c837485xREACTy8c3xugx",
              "pool_id": "autonomousgpu",
              "view_id": "react-zp650",
              "gpu_capable": true,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "port": 3000,
                    "ports": [],
                    "userCode": "",
                    "openFiles": [],
                    "showFiles": true,
                    "allowClose": true,
                    "allowSubmit": false,
                    "terminalTitle": "BASH",
                    "actionButtonText": "Desktop",
                    "openTerminalOnStartup": true
                  },
                  "kind": "react"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            },
            {
              "id": 837605,
              "key": "f482edc8-87aa-4972-b1af-9f04e3353592",
              "title": "Solution",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Solution",
              "instructor_notes": ""
            },
            {
              "id": 837606,
              "key": "8ba12a1c-cfee-4930-b936-2ef696a7646e",
              "title": "ND313 C1 L2 A10 Separating Point Clouds Solution",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "5aMtbD3criU",
                "china_cdn_id": "5aMtbD3criU.mp4"
              }
            }
          ]
        },
        {
          "id": 837611,
          "key": "3bb8391a-dda3-4077-93f0-3cfb0f62ffe7",
          "title": "RANSAC",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "3bb8391a-dda3-4077-93f0-3cfb0f62ffe7",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 837608,
              "key": "c8493091-101b-4103-81f2-3ddf661c82b0",
              "title": "Header Text",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# RANSAC",
              "instructor_notes": ""
            },
            {
              "id": 840287,
              "key": "cf320c1c-e14a-422f-833c-7cc6c95aec36",
              "title": "ND313 C1 L2 A11 RANSAC Overview [LB]",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "UD3LY0Btc58",
                "china_cdn_id": "UD3LY0Btc58.mp4"
              }
            },
            {
              "id": 840288,
              "key": "3a9a8460-24dd-45eb-8a5c-1bc2402df1f1",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "RANSAC stands for Random Sample Consensus, and is a method for detecting outliers in data. RANSAC runs for a max number of iterations, and returns the model with the best fit. Each iteration randomly picks a subsample of the data and fits a model through it, such as a line or a plane. Then the iteration with the highest number of inliers or the lowest noise is used as the best model.",
              "instructor_notes": ""
            },
            {
              "id": 837609,
              "key": "86cc667d-28e7-4b59-97cd-09cef69dae3f",
              "title": "RANSAC",
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2019/March/5c840491_ransac-linie-animiert/ransac-linie-animiert.gif",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/86cc667d-28e7-4b59-97cd-09cef69dae3f",
              "caption": "RANSAC algorithm for line fitting with outliers",
              "alt": "RANSAC algorithm for line fitting with outliers",
              "width": 639,
              "height": 480,
              "instructor_notes": null
            },
            {
              "id": 837610,
              "key": "3dd9e090-720d-473c-a310-a282fbdb3f1f",
              "title": "RANSAC overview",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "One type of RANSAC version selects the smallest possible subset of points to fit. For a line, that would be two points, and for a plane three points. Then the number of inliers are counted, by iterating through every remaining point and calculating its distance to the model. The points that are within a certain distance to the model are counted as inliers. The iteration that has the highest number of inliers is then the best model. This will be the version that you will implement in this quiz.\n\nOther methods of RANSAC could sample some percentage of the model points, for example 20% of the total points, and then fit a line to that. Then the error of that line is calculated, and the iteration with the lowest error is the best model. This method might have some advantages since not every point at each iteration needs to be considered. It’s good to experiment with different approaches and time results to see what works best. \n ",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 837619,
          "key": "1d97aa5f-1d6b-48a8-866c-023f191dcc0c",
          "title": "Implementing RANSAC for Lines",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "1d97aa5f-1d6b-48a8-866c-023f191dcc0c",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 837612,
              "key": "988c12fc-8d02-4242-b140-01355550585a",
              "title": "Implementing RANSAC for Lines",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# Implementing RANSAC for Lines",
              "instructor_notes": ""
            },
            {
              "id": 840289,
              "key": "307ee19d-bf26-42d7-bc65-c73db0dd4a73",
              "title": "ND313 C1 L2 A12 Implementing RANSAC For Lines [LB]",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "IjT37Y7bpQU",
                "china_cdn_id": "IjT37Y7bpQU.mp4"
              }
            },
            {
              "id": 840290,
              "key": "eb355928-86ee-48bc-8b45-38aef56243d2",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Here you will complete a quiz that has you implement RANSAC for fitting a line in 2D point data with outliers. The quiz is located in `src/quiz/ransac/ransac2d.cpp`, and the function to fill out is `Ransac`, which takes in arguments for a point cloud, max iterations to run, and distance tolerance. The point cloud is actually `pcl::PointXYZ` but the z component will be set to zero to make things easy to visualize in 2D space. \n\nThe data shown below was generated by creating a line with points slightly scattered, and then outliers were added by randomly placing points in the scene. You want to be able to identify which points belong to the line that was originally generated and which points are outliers. To do this you will randomly sample two points from the cloud and fit a line between the points. A helpful line equation for this problem can be seen below.",
              "instructor_notes": ""
            },
            {
              "id": 837613,
              "key": "089d6152-767d-43f4-b8cb-7a9619769ab0",
              "title": "Point Data",
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2019/March/5c8405b5_ransac2d/ransac2d.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/089d6152-767d-43f4-b8cb-7a9619769ab0",
              "caption": "Simple 2D Point Cloud Data",
              "alt": "Simple 2D Point Cloud Data",
              "width": 953,
              "height": 515,
              "instructor_notes": null
            },
            {
              "id": 837614,
              "key": "da8b22a8-acc5-4cc5-a2ac-c19e3954c0c6",
              "title": "RANSAC Implementation",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Equation of a Line Through Two Points in 2D\n\nFor variables <span id=\"mathquill\">x</span> and <span id=\"mathquill\">y</span> and coefficients <span id=\"mathquill\">A</span>, <span id=\"mathquill\">B</span>, and <span id=\"mathquill\">C</span>, the general equation of a line is:\n<div class=\"mathquill\">Ax + By + C = 0</div>\n\n\nGiven two points: point1  <span id=\"mathquill\">(x1, y1)</span> and point2  <span id=\"mathquill\">(x2, y2)</span>, the line through point1 and point2 has the specific form:\n<div class=\"mathquill\">(y1 -y2)x + (x2 -x1)y + (x1*y2 -x2*y1) = 0</div>\n## Using Distance to Find the Best Line\nAfter fitting the line you can then iterate through all the points and determine if they are inliers by measuring how far away each point is from the line. You can do this for each iteration keeping track of which fitted line had the highest number of inliers. The line with the most inliers will be the best model. The equation for calculating distance between a point and line is shown below. For further details see, https://brilliant.org/wiki/dot-product-distance-between-point-and-a-line/.\n\n- Line formula <span class=\"mathquill\">Ax + By + C = 0</span>\n- Point <span class=\"mathquill\">(x,y)</span>\n- Distance <span class=\"mathquill\">d = |Ax+By+C|/sqrt(A^2+B^2)</span>\n\nBelow are the results of doing RANSAC to fit a line from the data above. Inliers are green while outliers are red. The function had a max iteration count of 50 and a distance tolerance of 0.5. The max iteration size to run depends on the ratio of inliers to the total number of points. The more inliers our data contains the higher the probability of selecting inliers to fit the line to, and the fewer iterations you need to get a high probability of selecting a good model.",
              "instructor_notes": ""
            },
            {
              "id": 837615,
              "key": "30110f4b-011e-4fe1-83ec-0c6c50eef06f",
              "title": "Point Data Segmented",
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2019/March/5c8405c3_ransac2dfitted/ransac2dfitted.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/30110f4b-011e-4fe1-83ec-0c6c50eef06f",
              "caption": "Fitted Line using RANSAC",
              "alt": "Fitted Line using RANSAC",
              "width": 943,
              "height": 515,
              "instructor_notes": null
            },
            {
              "id": 837616,
              "key": "18f4e786-b442-4c28-bc0f-84d3ba626add",
              "title": "Instructions",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Instructions\n\n- Go to `src/quiz/ransac/ransac2d.cpp`\n- Complete the function `Ransac` following the instructions above \n\n## Compile/Run\n- Go to `src/quiz/ransac`\n- `mkdir build`\n- `cd build`\n- `cmake ..`\n- `make`\n- `./quizRansac`\n",
              "instructor_notes": ""
            },
            {
              "id": 837635,
              "key": "79c68ed4-bf98-407d-afb9-764782c7c26e",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r831540c837485xREACTy8c3xugx",
              "pool_id": "autonomousgpu",
              "view_id": "react-cf4a7",
              "gpu_capable": true,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "port": 3000,
                    "ports": [],
                    "userCode": "",
                    "openFiles": [],
                    "showFiles": true,
                    "allowClose": true,
                    "allowSubmit": false,
                    "terminalTitle": "BASH",
                    "actionButtonText": "Desktop",
                    "openTerminalOnStartup": true
                  },
                  "kind": "react"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            },
            {
              "id": 837617,
              "key": "498de5cf-b011-4534-a333-aa6bae324577",
              "title": "Solution",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Solution",
              "instructor_notes": ""
            },
            {
              "id": 837618,
              "key": "f0415fff-b5a5-41ad-a511-7049f8f32041",
              "title": "ND313 C1 L2 A17 Implementing RANSAC For Lines Solution [Too Long]",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "csyq4eYM480",
                "china_cdn_id": "csyq4eYM480.mp4"
              }
            }
          ]
        },
        {
          "id": 837622,
          "key": "00360234-41c4-4ff7-aeb2-1ee2918db24d",
          "title": "Extending RANSAC to Planes",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "00360234-41c4-4ff7-aeb2-1ee2918db24d",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 837620,
              "key": "8f7a3f0c-e20f-4fab-82c8-06edcbff864d",
              "title": "Header Text",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# Extending RANSAC to Planes",
              "instructor_notes": ""
            },
            {
              "id": 837621,
              "key": "a5dcf3b6-28e6-4d4c-8a4c-2bf683604d7a",
              "title": "Extending RANSAC to Plane",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Now that you are getting the hang of RANSACing it, and understanding RANSAC for  fitting a line, you can do the same thing for fitting a plane in a 3D point cloud. ***Your implementation will be used as part of your project, so be sure to complete the implementation in the exercise below!***\n\nIf you have completed the previous exercise, you can modify your code by using the equation for a plane using three points, and the distance formula for a point to a plane.\n\n## Equation of a Plane through Three Points\n\n<div class=\"mathquill\">Ax + By + Cz + D = 0</div>\nFor  \n- <span class=\"mathquill\">point1 = (x1, y1, z1)</span>\n- <span class=\"mathquill\">point2 = (x2, y2, z2)</span>\n- <span class=\"mathquill\">point3 = (x3, y3, z3)</span>\n\nUse <span class=\"mathquill\">point1</span> as a reference and define two vectors on the plane <span class=\"mathquill\"> v1</span> and <span class=\"mathquill\">v2</span> as follows:\n\n- Vector <span class=\"mathquill\">v1</span> travels from <span class=\"mathquill\">point1</span> to <span class=\"mathquill\">point2</span>.\n- Vector <span class=\"mathquill\">v2</span> travels from <span class=\"mathquill\">point1</span> to <span class=\"mathquill\">point3</span>\n\n<div class=\"mathquill\">v1 = < x2 - x1, y2 - y1, z2 - z1 ></div>\n<div class=\"mathquill\">v2 = < x3 - x1, y3 - y1, z3 - z1 ></div>\n\nFind normal vector to the plane by taking cross product of <span class=\"mathquill\">v1 \\times v2</span>: \n<div class=\"mathquill\"> v1 \\times v2 = <(y2-y1)(z3-z1)-(z2-z1)(y3-y1),</div>\n<div class=\"mathquill\"> (z2-z1)(x3-x1)-(x2-x1)(z3-z1),</div>\n<div class=\"mathquill\">(x2-x1)(y3-y1)-(y2-y1)(x3-x1)></div>\n\nTo simplify notation we can write it in the form \n<div class=\"mathquill\">v1 \\times v2 = < i, j, k > </div>\n\nthen ,\n\n<div class=\"mathquill\">i(x-x1)+j(y-y1)+k(z-z1) = 0,</div>\n<div class=\"mathquill\">ix + jy + kz -( ix1 + jy1 + kz1 ) = 0</div>\n\n<div class=\"mathquill\">A = i,</div>\n\n<div class=\"mathquill\">B = j,</div>\n\n<div class=\"mathquill\">C = k,</div>\n\n<div class=\"mathquill\">D = -( ix1 + jy1 + kz1 )</div>\n\n## Distance between point and plane\n\nIf the plane is <div class=\"mathquill\">Ax + By + Cz + D = 0,</div> \nthen given a point <span class=\"mathquill\">(x,y,z)</span>, the distance from the point to the plane is: <div class=\"mathquill\">d = |A*x+B*y+C*z+D|/sqrt(A^2+B^2+C^2).</div>\nWhen implementing RANSAC, try timing how long it takes to execute and compare its time to PCL's built in RANSAC functions.\n\n## Instructions\n\n- In the workspace below, change line 99, to use `CreateData3D`\n- Once Ransac plane fitting is working well, copy the code and extend it to `pointProcessor`, `Segment` function\n\n```\n/ Create data\npcl::PointCloud<pcl::PointXYZ>::Ptr cloud = CreateData3D();\n```\n\n- Modify the `Ransac` function or create a new` RansacPlane` function and use the same implementation as before but now with Plane and Point formulas.\n\n\n\n",
              "instructor_notes": ""
            },
            {
              "id": 837644,
              "key": "11ea2c1d-ad50-41d7-88de-5a578bfd6e0a",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r831540c837485xREACTy8c3xugx",
              "pool_id": "autonomousgpu",
              "view_id": "react-guw58",
              "gpu_capable": true,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "port": 3000,
                    "ports": [],
                    "userCode": "",
                    "openFiles": [],
                    "showFiles": true,
                    "allowClose": true,
                    "allowSubmit": false,
                    "terminalTitle": "BASH",
                    "actionButtonText": "Desktop",
                    "openTerminalOnStartup": true
                  },
                  "kind": "react"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 858915,
          "key": "077821f9-1c58-4c2f-928c-75ef4e5056ac",
          "title": "Michael on Segmenting the Plane",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "077821f9-1c58-4c2f-928c-75ef4e5056ac",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 858916,
              "key": "ea786d8d-03b8-4f82-81d8-cf4962841bd4",
              "title": "ND313 Michael Intv 18 Do You Generall Segment Out The Ground Plane From A Point Cloud V2",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "2rJpIjcfUTo",
                "china_cdn_id": "2rJpIjcfUTo.mp4"
              }
            }
          ]
        },
        {
          "id": 837625,
          "key": "d34841d8-d211-4dd1-a068-5fdbf4cfc00d",
          "title": "Outro",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "d34841d8-d211-4dd1-a068-5fdbf4cfc00d",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 837623,
              "key": "e9603d5f-771f-40db-b281-0bdb7282f743",
              "title": "Header Text",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# Outro",
              "instructor_notes": ""
            },
            {
              "id": 837624,
              "key": "f1c3d548-8ceb-462d-8020-e7528d567f29",
              "title": "ND313 C1 L2 A19 Segmentation Outro",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "_fn_NXX1XtI",
                "china_cdn_id": "_fn_NXX1XtI.mp4"
              }
            }
          ]
        }
      ]
    }
  },
  "_deprecated": [
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    }
  ]
}